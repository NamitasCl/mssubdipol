services:
  database:
    image: postgres:15
    container_name: pgdatabase
    environment:
      # OJO: Usuario y contraseña por defecto no son seguros para producción.
      # Considera usar secretos de Docker o variables de entorno más seguras.
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ipqq7890
      # Puedes añadir POSTGRES_DB aquí si quieres que cree una DB por defecto al iniciar,
      # aunque init.sql también puede hacerlo.
      # POSTGRES_DB: tu_db_inicial # Opcional
    volumes:
      # ¡Excelente! Esto inicializa la DB en el primer arranque y persiste los datos.
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
      # ¡Importante! Agrega un volumen para persistir los datos de la DB
      - pgdata-prod-alt:/var/lib/postgresql/data-prod-alt # Mapea el directorio de datos de Postgres a un volumen
    ports:
      # Mapea el puerto interno 5432 al 55432 en el host.
      # Útil para acceder desde tu máquina con un cliente SQL (DBeaver, pgAdmin, etc.)
      # Los microservicios usarán el puerto interno 5432.
      - "55433:5432"
    restart: unless-stopped
    networks:
      - ms-network-prod-alt # <-- ¡Añadir! Conecta la DB a la red ms-network

  auth:
    build:
      context: ./auth
    container_name: auth-prod-alt
    environment:
      # Correcto uso del nombre del servicio 'database' y el puerto interno 5432
      SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/auth # Asume que init.sql crea la DB 'auth'
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: ipqq7890
      # Otras variables de entorno para auth si las necesita (puertos de otros servicios, secrets, etc.)
      # Por ejemplo, si auth necesita comunicarse con common-services o turnos:
      # COMMON_SERVICES_URL: http://commonservices:8011
      # TURNOS_URL: http://turnos:8010
    depends_on:
      - database # Asegura que la DB esté iniciada antes que auth
    volumes:
      - ./auth/config/application.yml:/app/config/application.yml # Mapea el archivo de configuración
    ports:
      - "8030:8009" # Mapea el puerto 8009 del contenedor al 8009 del host
    restart: unless-stopped
    networks:
      - ms-network-prod-alt # <-- ¡Añadir! Conecta auth a la red ms-network

  turnos:
    build:
      context: ./turnos
    container_name: turnos-prod-alt
    environment:
      # Correcto uso del nombre del servicio 'database' y el puerto interno 5432
      SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/turnos # Asume que init.sql crea la DB 'turnos'
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: ipqq7890
      # Otras variables de entorno para turnos
      # Por ejemplo, si turnos necesita common-services o auth:
      # COMMON_SERVICES_URL: http://commonservices:8011
      # AUTH_URL: http://auth:8009
    depends_on:
      - database # turnos probablemente necesita la DB
      - commonservices # Si turnos depende de common-services lógicamente
      - auth # Si turnos depende de auth lógicamente
    ports:
      - "8031:8010" # Mapea el puerto 8010 del contenedor al 8010 del host
    restart: unless-stopped
    networks:
      - ms-network-prod-alt # <-- ¡Añadir! Conecta turnos a la red ms-network

  commonservices:
    build:
      context: ./commonservices
    container_name: commonservices-prod-alt
    environment:
      # Correcto uso del nombre del servicio 'database' y el puerto interno 5432
      SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/commonservices # Asume que init.sql crea la DB 'commonservices'
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: ipqq7890
      # Otras variables de entorno para common-services
      # Por ejemplo, si common-services necesita auth:
      # AUTH_URL: http://auth:8009
    depends_on:
      - database # common-services probablemente necesita la DB
      - auth # Si common-services depende de auth lógicamente
    ports:
      - "8032:8011" # Mapea el puerto 8011 del contenedor al 8011 del host
    restart: unless-stopped
    networks:
      - ms-network-prod-alt # <-- ¡Añadir! Conecta common-services a la red ms-network

  nginx-docker:
    image: nginx:latest
    container_name: nginx-docker
    ports:
      - "8088:80"    # Así lo pruebas en http://TU-IP:8088/
    volumes:
      - ./nginx-docker.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - frontend
      - auth
      - turnos
      - commonservices
    networks:
      - ms-network-prod-alt

  frontend:
    build:
      context: ./frontend
    container_name: frontend-prod-alt
    # Asumiendo que tu frontend necesita llamar a las APIs de los backends
    #environment:
      # Aquí usas los nombres de servicio y los puertos internos de los backends
      # Si tu frontend hace llamadas directas:
      # VITE_AUTH_API_URL: "http://auth:8009/" # Ejemplo de URL interna dentro de la red
      # VITE_TURNOS_API_URL: "http://turnos:8010/" # Ejemplo de URL interna dentro de la red
      # VITE_COMMON_SERVICES_API_URL: "http://commonservices:8011/" # Ejemplo de URL interna dentro de la red
      # Si usaras un API Gateway o proxy inverso, el frontend llamaría a ese Gateway/proxy
      # GATEWAY_URL: http://gateway_service_name:gateway_port/api/
    depends_on:
      - auth # Asegura que los backends estén iniciados antes que el frontend
      - turnos
      - commonservices
    ports:
      - "8033:80" # Mapea el puerto 3000 del contenedor al 3000 del host
    restart: unless-stopped
    networks:
      - ms-network-prod-alt # <-- ¡Añadir! Conecta el frontend a la red ms-network


# Define los volúmenes para la persistencia
volumes:
  pgdata-prod-alt: # Volumen para los datos de PostgreSQL

# Define la red personalizada
networks:
  ms-network-prod-alt:
    driver: bridge # Tipo de red bridge es el más común para este caso
